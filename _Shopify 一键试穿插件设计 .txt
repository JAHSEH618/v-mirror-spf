YOU ASKED:

我要用shopify官方的脚手架下面的React
Router框架，做一个shopify一键换装插件，能够在商家在自己的店铺安装之后，在用户访问商品界面的时候可以有一个浮球，点击之后是一键试穿的弹窗，用户上传自己的照片之后，插件自动识别当前界面的商品（衣服），然后输出用户试穿这件衣服的照片




结合shopify的官方文档以及脚手架，输出完成这个插件的产品设计

---

GEMINI REPLIED:

这是一个结合了Shopify最新开发范式（Remix框架 + Theme App Extensions）与你现有的AI技术栈（Python/FastAPI "V-Mirror" 项目）的完整产品设计方案。


1. 系统架构设计 (SYSTEM ARCHITECTURE)

由于Shopify App目前默认采用Remix (Node.js) 作为全栈框架，而你的AI核心逻辑在Python (V-Mirror) 中，我们需要采用 前后端分离 + AI微服务 的架构。

 * Storefront (前端/店铺端):
   
   * 技术栈: Shopify Theme App Extension (Liquid, JavaScript, CSS).
   
   * 职责: 在商品详情页渲染浮球、处理弹窗交互、获取当前商品图片、压缩用户上传的图片。

 * App Backend (Shopify中间层):
   
   * 技术栈: Shopify CLI (Remix).
   
   * 职责: 鉴权 (OAuth)、计费 (Billing API)、作为 BFF (Backend for Frontend) 转发请求、隐藏AI服务的真实地址和密钥。

 * AI Core (AI推理层):
   
   * 技术栈: Python (FastAPI/V-Mirror).
   
   * 职责: 接收 user_image 和 cloth_image，运行试穿模型，返回结果图片链接。

----------------------------------------------------------------------------------------------------------------------------------


2. 核心功能流程 (USER FLOW)

 1. 初始化: 用户访问店铺商品页 (PDP)。插件检测当前页面类型，加载“一键试穿”浮球 (Floating Widget)。

 2. 触发: 用户点击浮球，打开模态框 (Modal)。

 3. 数据捕获:
    
    * 插件自动读取当前商品的主图 URL ({{ product.featured_image | image_url }}).
    
    * 用户在模态框中上传全身照。

 4. 请求处理:
    
    * 前端将图片数据发送给 Remix Backend (/api/try-on)。
    
    * Remix Backend 验证请求合法性，将数据转发给 V-Mirror Python 服务。

 5. AI推理: V-Mirror 处理图像生成，返回合成后的图片 URL。

 6. 结果展示: 模态框展示试穿效果图，提供下载或对比功能。

----------------------------------------------------------------------------------------------------------------------------------


3. 详细技术实现方案

A. 项目脚手架初始化

使用Shopify CLI生成基于Remix的项目结构：

Bash


npm init @shopify/app@latest -- --template remix


随后，你需要创建一个 Theme App Extension 来实现浮球功能，而不是直接修改商家代码：

Bash


npm run shopify app generate extension -- --template theme_app_extension --name try-on-widget


B. 前端交互 (THEME APP EXTENSION)

Shopify现在的标准做法是使用 App Embed Block。这允许商家在编辑器中一键开启/关闭插件，且不残留代码。

文件路径: extensions/try-on-widget/blocks/star_rating.liquid (建议重命名为 try_on_widget.liquid)

核心逻辑 (Liquid + JS):

 * Schema: 定义插件在编辑器里的设置（如浮球颜色、位置）。

 * Context识别: 确保只在 product 页面加载。

代码段


{% if request.page_type == 'product' %}
  <div id="v-mirror-widget" style="position: fixed; bottom: 20px; right: 20px; z-index: 9999;">
    <button id="try-on-btn">一键试穿</button>
  </div>

  <div id="v-mirror-modal" class="hidden">
    <input type="file" id="user-photo-upload" accept="image/*" />
    <img id="product-image-ref" src="{{ product.featured_image | image_url: width: 600 }}" hidden />
    <div id="result-area"></div>
  </div>

  <script>
    // 简单的原生 JS 处理点击和 fetch 请求
    document.getElementById('try-on-btn').addEventListener('click', () => {
       // 打开弹窗逻辑
    });
    
    // 处理上传并调用 Remix 后端 API
    async function handleTryOn(file) {
      const formData = new FormData();
      formData.append('userImage', file);
      // 获取当前商品图 URL
      formData.append('clothImageUrl', "{{ product.featured_image | image_url: master }}");
      
      // 注意：这里请求的是你的 Remix App 提供的 App Proxy 或公开 API
      const response = await fetch('/apps/v-mirror/api/generate', { 
        method: 'POST', 
        body: formData 
      });
      // ...处理响应
    }
  </script>
{% endif %}

{% schema %}
{
  "name": "V-Mirror Widget",
  "target": "body",
  "settings": [
    { "type": "color", "id": "btn_color", "label": "Button Color", "default": "#000000" }
  ]
}
{% endschema %}


C. 后端桥接 (REMIX APP)

在 app/routes/api.generate.jsx 中创建 API 路由。这个路由充当你的 Python 后端的代理。

 1. Action Function: 接收前端传来的 FormData。

 2. 调用 Python 服务: 使用 fetch 将数据转发给你的 V-Mirror FastAPI 接口。

 3. 安全: 在这里添加 API Key 验证，防止 Python 接口直接暴露在公网被滥用。

JavaScript


// app/routes/api.generate.jsx
import { json } from "@remix-run/node";

export const action = async ({ request }) => {
  // 1. 获取前端数据
  const formData = await request.formData();
  const userImage = formData.get("userImage");
  const clothImageUrl = formData.get("clothImageUrl");

  // 2. 构造发送给 V-Mirror Python 服务的请求
  // 建议将 Python 服务部署在 GPU 服务器上，通过内网或加密外网通信
  const pythonServiceUrl = process.env.V_MIRROR_API_URL; 
  
  try {
    const aiResponse = await fetch(`${pythonServiceUrl}/try-on`, {
      method: "POST",
      // 转发数据逻辑...
    });
    
    const result = await aiResponse.json();
    return json({ success: true, imageUrl: result.output_url });
    
  } catch (error) {
    return json({ success: false, error: "AI Processing Failed" }, { status: 500 });
  }
};


D. PYTHON AI 服务 (V-MIRROR 现有项目)

你需要确保你的 FastAPI 项目有一个对应的接口：

 * Endpoint: POST /try-on

 * Input: user_image (file/base64), cloth_image_url (string)

 * Process:
   
   1. 下载 cloth_image_url。
   
   2. 预处理 (Resize/Crop)。
   
   3. 运行 IDM-VTON 或其他试穿模型。
   
   4. 上传结果图到对象存储 (S3/OSS)。
   
   5. 返回结果图的公共 URL。

----------------------------------------------------------------------------------------------------------------------------------


4. 关键挑战与解决方案

挑战解决方案推理延迟 (Latency)AI 生成通常需要 5-10 秒。前端需要实现Loading 状态动画。如果生成时间过长（>30秒），建议改为“异步任务+轮询”机制，或者通过 WebSocket 推送结果。跨域 (CORS)Shopify
店铺前端直接请求 Python 后端会被浏览器拦截。解决方案：利用 Shopify 的App Proxy功能，将/apps/v-mirror的请求自动转发给你的 Remix App，再由 Remix 请求 Python。并发与排队如果同时有多个用户试穿，GPU
显存可能不足。在 V-Mirror Python 端引入Celery + Redis消息队列，控制并发处理数量。

导出到 Google 表格

----------------------------------------------------------------------------------------------------------------------------------


5. 下一步行动

为了推进这个项目，我建议你按照以下顺序进行开发：

 1. Python端: 确保 V-Mirror 的 FastAPI 接口已经能够接受 HTTP 请求并返回结果（即使先返回假数据）。

 2. Shopify端: 使用 CLI 创建项目，并编写 theme_app_extension 代码，确保浮球能显示在测试店铺的商品页上。

 3. 联调: 在 Remix 中写好转发逻辑，打通 "Storefront -> Remix -> Python" 的链路。

Would you like me to generate the specific liquid code for the floating button and the popup modal structure?




---

YOU ASKED:

不考虑我目前的python+fastapi的项目，我要完全依赖shopify的react router的框架

---

GEMINI REPLIED:

如果完全不使用你自己托管的 Python/FastAPI 后端，而是完全依赖 Shopify 官方脚手架 (Remix/Node.js)，我们需要解决一个核心技术矛盾：

Node.js 环境无法高效运行大型 AI 图像生成模型 (如 IDM-VTON)。

因此，"完全依赖 Shopify 框架" 的实现路径变成了：Shopify App (Remix) 作为业务逻辑中枢 + Serverless AI API (如 Replicate) 作为算力后端。这意味着你的 Remix
应用将只负责“发号施令”，而将繁重的 GPU 计算外包给成熟的 API 服务。

以下是基于 Shopify CLI (Remix) + Replicate API 的完整产品设计方案。

----------------------------------------------------------------------------------------------------------------------------------


1. 系统新架构：SERVERLESS 模式

在这种架构下，你的 Shopify App 不需要维护任何服务器，只需编写 Node.js 代码即可。

 * 前端 (Theme App Extension):
   
   * 载体: Liquid Block + 原生 JavaScript。
   
   * 作用: 在店铺页面渲染浮球，抓取当前商品图，上传用户图。

 * 后端 (Shopify App / Remix):
   
   * 载体: Shopify CLI 生成的 Node.js 服务器。
   
   * 作用: 接收前端图片 -> 调用 Replicate API (运行 IDM-VTON 模型) -> 轮询状态 -> 返回结果。

 * AI 算力 (第三方 API):
   
   * 服务商: Replicate (推荐，支持按次计费，无需维护 GPU)。
   
   * 模型: google/idm-vton (目前开源界效果最好的试穿模型)。

----------------------------------------------------------------------------------------------------------------------------------


2. 核心交互流程 (USER FLOW)

 1. 上传与请求: 用户在弹窗上传照片 -> 前端 JS 将“用户照片(Base64/File)”和“商品图 URL”发送给 Remix 后端。

 2. 任务提交: Remix 后端收到请求，调用 Replicate API predictions.create。

 3. 等待机制: 由于 AI 生成需要 5-10 秒，Remix 无法立即返回结果。
    
    * 方案 A (简单): 前端显示 Loading，JS 每隔 2 秒轮询 Remix 接口查询进度。
    
    * 方案 B (进阶): Remix 收到 Replicate 的 Webhook 回调（配置较复杂，建议先用方案 A）。

 4. 展示: 轮询成功，获取到 Replicate 返回的图片 URL，前端更新 DOM 展示试穿照。

----------------------------------------------------------------------------------------------------------------------------------


3. 详细技术实现 (代码级设计)

第一步：依赖准备

在你的 Shopify Remix 项目中安装 Replicate SDK：

Bash


npm install replicate


第二步：后端 API 路由 (REMIX)

我们需要在 app/routes 下创建两个 API 接口：一个用于提交任务，一个用于查询状态。为了解决跨域问题，我们将使用 App Proxy (需要在 shopify.app.toml 中配置 app_proxy)。

1. 提交任务接口 (app/routes/api.try-on.start.jsx)

JavaScript


import { json } from "@remix-run/node";
import Replicate from "replicate";

export const action = async ({ request }) => {
  // 初始化 Replicate
  const replicate = new Replicate({
    auth: process.env.REPLICATE_API_TOKEN,
  });

  const formData = await request.formData();
  const userImage = formData.get("userImage"); // 假设前端传base64或公网URL
  const clothImage = formData.get("clothImage");

  try {
    // 调用 IDM-VTON 模型
    const prediction = await replicate.predictions.create({
      version: "c871bb9b04660741b1153de5653af650117a5824921606774c865f1a58204b40", // IDM-VTON 的模型指纹
      input: {
        human_img: userImage,
        garm_img: clothImage,
        garment_des: "clothing", 
        // 其他模型特定参数
      },
    });

    // 返回任务 ID 给前端，用于轮询
    return json({ id: prediction.id, status: prediction.status });
  } catch (error) {
    return json({ error: error.message }, { status: 500 });
  }
};


2. 状态查询接口 (app/routes/api.try-on.status.jsx)

JavaScript


import { json } from "@remix-run/node";
import Replicate from "replicate";

export const loader = async ({ request }) => {
  const url = new URL(request.url);
  const predictionId = url.searchParams.get("id");

  const replicate = new Replicate({
    auth: process.env.REPLICATE_API_TOKEN,
  });

  const prediction = await replicate.predictions.get(predictionId);

  // 如果完成，output 里会有图片 URL
  return json({ 
    status: prediction.status, 
    output: prediction.output 
  });
};


第三步：前端扩展 (THEME APP EXTENSION)

这部分代码在 extensions/try-on-widget/blocks/widget.liquid 中。不使用 React，而是使用原生 JS 来处理这简单的交互。

JavaScript


<script>
  async function startTryOn() {
    const fileInput = document.getElementById('user-upload');
    const statusDiv = document.getElementById('status-msg');
    
    // 1. 将文件转为 Base64 (Replicate 接受 URL 或 Base64)
    const file = fileInput.files[0];
    const reader = new FileReader();
    
    reader.onloadend = async function() {
      const base64data = reader.result;
      
      // 2. 发送到 Remix App Proxy (假设配置了 /apps/v-mirror 前缀)
      const formData = new FormData();
      formData.append('userImage', base64data);
      // 获取当前页面的商品图
      formData.append('clothImage', "{{ product.featured_image | image_url: 'master' }}");

      statusDiv.innerText = "正在排队处理...";
      
      const startRes = await fetch('/apps/v-mirror/api/try-on/start', {
        method: 'POST',
        body: formData
      });
      const startData = await startRes.json();

      if (startData.id) {
        pollStatus(startData.id);
      }
    }
    
    reader.readAsDataURL(file);
  }

  // 3. 轮询逻辑
  async function pollStatus(id) {
    const statusDiv = document.getElementById('status-msg');
    const resultImg = document.getElementById('result-img');
    
    const interval = setInterval(async () => {
      const res = await fetch(`/apps/v-mirror/api/try-on/status?id=${id}`);
      const data = await res.json();
      
      if (data.status === 'succeeded') {
        clearInterval(interval);
        statusDiv.innerText = "试穿完成！";
        resultImg.src = data.output; // Replicate 返回的图片 URL
        resultImg.style.display = 'block';
      } else if (data.status === 'failed') {
        clearInterval(interval);
        statusDiv.innerText = "生成失败，请重试。";
      } else {
        statusDiv.innerText = "AI 正在绘制中 (" + data.status + ")...";
      }
    }, 2000); // 每2秒查一次
  }
</script>


----------------------------------------------------------------------------------------------------------------------------------


4. 关键配置清单

为了让这个“纯 Shopify 框架”方案跑通，你需要完成以下配置：

 1. Shopify App Proxy (应用代理):
    
    * 在 shopify.app.toml 中配置 Proxy，这样店铺前端 (your-store.myshopify.com/apps/v-mirror) 才能安全地访问你的 Remix 后端，而不会暴露 API Key，也不受浏览器跨域限制。
    
    * 配置示例：
      
      Ini, TOML
      
      
      [app_proxy]
      url = "https://your-remix-app-url.com/api"
      subpath = "v-mirror"
      prefix = "apps"
      

 2. Environment Variables:
    
    * 在 Remix 项目的 .env 文件中添加 REPLICATE_API_TOKEN=r8_xyz...。

 3. 图片处理注意事项:
    
    * Base64 上传对于大图可能会导致 Payload 过大。优化建议：在前端使用 Canvas 将用户图片压缩到 1024px 宽以内再转 Base64 上传。


5. 总结：该方案的优缺点

 * 优点:
   
   * 架构极简: 只有 Shopify App 一个项目，没有额外的 Python 服务器维护成本。
   
   * 部署方便: 可以直接部署在 Shopify 托管的 Hosting 上（如果是 Hydrogen）或者 Fly.io/Vercel（标准的 Remix 部署）。
   
   * 符合官方范式: 完全使用 Shopify 推荐的 Remix + App Proxy + Theme Extension 链路。

 * 缺点:
   
   * 成本: Replicate 是按秒计费的，如果用户量巨大，成本会高于自己租 GPU 服务器。
   
   * 冷启动: API 调用有时会有冷启动延迟。

Would you like me to guide you on how to set up the shopify.app.toml configuration for the App Proxy specifically?




---

YOU ASKED:

我依赖的是https://shopify.dev/docs/apps/build/build?framework=reactRouter这个框架

首先 先给出产品设计

---

GEMINI REPLIED:

基于 Shopify 官方文档中推荐的 Remix (React Router) 框架，结合 Theme App Extensions 技术，我为你制定了以下的产品设计方案 (Product Design Document)。

这份设计方案旨在利用 Shopify 的 React Router 后端作为安全中转站，连接店铺前端与云端 AI 服务。

----------------------------------------------------------------------------------------------------------------------------------


1. 产品架构概览 (ARCHITECTURE OVERVIEW)

由于 React Router (运行在 Node.js 环境) 无法直接高效运行重型 Python AI 模型，且前端不能直接暴露 API Key，我们将采用 BFF (Backend for Frontend) 架构。

 * Storefront (客户端): 基于 Shopify Theme App Extensions (Liquid + Vanilla JS/React)。它负责 UI 展示和用户交互。

 * App Backend (服务端): 基于 Shopify App (React Router)。它充当安全网关，利用 App Proxy 接收前端请求，进行鉴权、计费检查，然后调用第三方 AI API。

 * AI Engine (算力层): 外部 Serverless AI API (推荐 Replicate 或类似服务)，运行 Virtual Try-On 模型 (如 IDM-VTON)。

----------------------------------------------------------------------------------------------------------------------------------


2. 核心功能模块设计

A. 商家端 (ADMIN DASHBOARD)

这是商家在 Shopify 后台安装你的 App 后看到的界面。

 * 技术栈: React, Polaris (Shopify 官方 UI 库), React Router。

 * 功能点:
   
   1. Onboarding (引导页): 指导商家如何将“一键试穿”模块添加到主题编辑器中。
   
   2. 外观配置 (可选): 如果不在主题编辑器里做，可以在这里配置全局样式（如浮球颜色、弹窗文案）。
   
   3. 用量与计费: 展示本月试穿次数，当超出免费额度时引导升级套餐 (利用 Shopify Billing API)。
   
   4. API Key 配置: (如果是私有部署) 允许商家填入自己的 AI 服务 Key，或者默认使用你提供的 Key。

B. 店铺前台 (STOREFRONT / THEME EXTENSION)

这是 C 端用户看到的一键换装界面。

 * 技术栈: Liquid (布局), CSS, Vanilla JavaScript (逻辑)。

 * 功能点:
   
   1. Floating Widget (浮球):
      
      * 仅在 product 页面加载。
      
      * 悬浮在右下角或“加入购物车”按钮旁。
   
   2. Try-On Modal (试穿弹窗):
      
      * 左侧: 显示当前商品的主图 (自动抓取 product.featured_image)。
      
      * 右侧: 用户上传区域 (Drag & Drop)。
      
      * 中间: “生成试穿”按钮。
   
   3. 结果展示: AI 生成完成后，替换右侧区域为试穿后的效果图，并提供“下载”或“对比原图”功能。

C. 后端服务 (APP BACKEND / REACT ROUTER)

这是核心的业务逻辑层，处理数据流转。

 * 技术栈: React Router (Action/Loader functions), Prisma (数据库 ORM).

 * API 路由设计:
   
   1. POST /api/proxy/generate:
      
      * 接收前端传来的 user_image (Base64) 和 product_image_url。
      
      * 验证请求来源（HMAC 校验，App Proxy 自动处理）。
      
      * 调用外部 AI API 启动任务。
      
      * 返回 task_id。
   
   2. GET /api/proxy/status:
      
      * 接收 task_id。
      
      * 轮询 AI API 状态。
      
      * 返回 status (processing/succeeded/failed) 和 output_url。

----------------------------------------------------------------------------------------------------------------------------------


3. 用户交互流程 (USER EXPERIENCE FLOW)

 1. 发现与触发:
    
    * 用户浏览连衣裙商品页。
    
    * 看到“AI 试穿”浮球，点击。

 2. 上传照片:
    
    * 弹窗打开，自动加载了当前的连衣裙图片。
    
    * 用户点击上传一张全身照。
    
    * 前端 JS 对图片进行压缩（限制在 1MB 以内，优化传输速度）。

 3. 生成过程:
    
    * 用户点击“开始试穿”。
    
    * 界面进入 Loading 状态（显示进度条或趣味动画，因为 AI 生成通常需要 5-10 秒）。
    
    * 前端通过 App Proxy 向 React Router 后端发送请求。

 4. 结果交付:
    
    * 后端轮询到结果，返回给前端。
    
    * 弹窗展示合成后的照片。
    
    * 用户满意后，点击“加入购物车”完成购买转化。

----------------------------------------------------------------------------------------------------------------------------------


4. 关键技术决策 (TECHNICAL SPECIFICATIONS)

1. 为什么使用 APP PROXY？

这是 Shopify 开发中的一个关键概念。

 * 问题: 如果你在前端 JS 直接 fetch('https://your-app.com/api')，会遇到跨域 (CORS) 问题，且无法携带 Session Cookie 验证身份。

 * 解决: 配置 App Proxy 后，前端请求 https://shop-url.com/apps/try-on/generate，Shopify 会自动将请求转发给你的 React Router 后端，并附带安全签名。这使得交互既安全又符合原生体验。

2. 图片处理策略

 * 用户图: 前端压缩 -> 转 Base64 或传至临时存储 -> 后端转发。

 * 商品图: 直接发送 URL。Shopify 的 CDN 图片通常是公开的，AI 服务可以直接读取。

3. AI 服务选型 (建议)

鉴于你现在不使用 Python 后端，建议对接 Replicate API 使用 IDM-VTON 模型。

 * 模型: google/idm-vton

 * 成本: 按秒计费，无服务器维护成本。

 * 输入: human_img, garm_img.

----------------------------------------------------------------------------------------------------------------------------------


5. 开发路线图 (NEXT STEPS)

按照 Shopify 官方脚手架的结构，开发顺序如下：

 1. 脚手架初始化: 使用 npm init @shopify/app@latest 创建 React Router 项目。

 2. 扩展创建: 运行 shopify app generate extension 创建 Theme App Extension。

 3. 前端 UI: 在 Liquid 文件中写 HTML/CSS 实现浮球和弹窗。

 4. 后端打通: 配置 shopify.app.toml 中的 App Proxy，并在 React Router 中编写对应的 API Action。

 5. AI 对接: 在后端集成 Replicate SDK。

这个设计完全遵循了 Shopify 的最新开发规范，利用 React Router 统一管理前后端路由，非常适合独立开发者快速落地。

你希望我先为你生成前端（Liquid/JS）的代码，还是后端（React Router API）的核心逻辑代码？




---

YOU ASKED:

首先，给出详细的产品功能设计清单

---

GEMINI REPLIED:

基于 Shopify 的 Remix (React Router) 框架和 Theme App Extensions 架构，以下是为你定制的详细产品功能设计清单。

这份清单将产品分为三大核心模块：买家端 (Storefront)、商家端 (Admin Dashboard) 和 服务端核心 (Backend Logic)。

----------------------------------------------------------------------------------------------------------------------------------


1. 买家端功能清单 (STOREFRONT / C端)

技术载体：Shopify Theme App Extensions (Liquid + Vanilla JS)

这是用户直接交互的界面，核心目标是无缝嵌入、交互流畅、引导清晰。

功能模块功能点 (Feature)详细描述 (Description)优先级入口组件悬浮触发球 (Floating Widget)在商品详情页 (PDP) 右下角或指定位置显示圆形图标或按钮，跟随页面滚动。P0智能显隐仅在特定类目（如 Clothing,
Dresses）或带有特定标签的商品页显示，避免在非服装商品（如鞋子、配件）出现。P1交互弹窗模态框 (Modal)点击悬浮球后弹出的居中窗口。支持响应式设计（手机端全屏，PC端居中）。包含关闭按钮和遮罩层。P0商品图预览自动抓取当前商品页的主图
(Featured Image) 并显示在弹窗左侧（或顶部）。P0图片上传用户照片上传支持拖拽上传或点击选择文件。限制文件格式 (JPG/PNG) 和大小 (e.g., <5MB)。P0图片预校验 (前端)(可选) 前端简单检测是否包含人像（如使用简单的 JS
库），防止上传风景照导致浪费 AI 算力。P2示例图选择提供几张默认的模特全身照供用户快速体验功能，无需上传自己照片。P1试穿核心生成状态反馈 (Loading)由于 AI 生成需 5-15
秒，需展示清晰的进度条、百分比或趣味动画，安抚用户等待焦虑。P0错误处理如果 AI 生成失败（如服务器繁忙、图片不合规），展示友好的错误提示并允许重试。P0结果展示效果图预览展示 AI
生成后的试穿图片。P0原图/效果图对比提供“按住对比”功能，按住看原图，松开看试穿图。P1图片下载允许用户将试穿结果保存到本地。P1一键加购在结果页直接提供“Add to Cart”按钮，促进转化。P2

导出到 Google 表格

----------------------------------------------------------------------------------------------------------------------------------


2. 商家端功能清单 (ADMIN DASHBOARD / B端)

技术载体：Shopify App (React / Polaris)

这是商家管理插件的地方，核心目标是配置简单、数据透明、计费清晰。

功能模块功能点 (Feature)详细描述 (Description)优先级安装引导Onboarding 流程引导商家进入“在线商店 > 主题编辑器”，激活 App Embed Block (应用嵌入块)。P0权限授权引导商家同意必要的权限范围
(read_products, write_script_tags 等)。P0外观配置可视化编辑器集成

不在 App 内部做，而是利用 Shopify Theme Editor 的 Schema 设置：

1. 浮球颜色/图标自定义。

2. 浮球位置 (左/右/偏移量)。

3. 弹窗文案 (标题、按钮文字) 自定义。

P0用量与计费额度仪表盘展示本月已使用的试穿次数 (Credits) 和剩余额度。P0套餐订阅 (Billing)集成 Shopify Billing API。提供不同套餐（如：免费版 50 次/月，专业版 500
次/月）。支持一键升级/降级。P0试穿记录历史记录概览(可选) 商家可以查看最近生成的试穿图片（需注意隐私合规，通常只存 URL，不存具体图片内容）。P2

导出到 Google 表格

----------------------------------------------------------------------------------------------------------------------------------


3. 服务端核心清单 (BACKEND / REMIX REACT ROUTER)

技术载体：Node.js + Prisma + App Proxy

这是连接 Shopify 和 AI 算力的桥梁，核心目标是安全、稳定、异步处理。

功能模块功能点 (Feature)详细描述 (Description)优先级API 网关App Proxy 路由配置/apps/try-on/*代理路由。验证 Shopify 签发的 HMAC
签名，确保请求来自合法的店铺前端。P0任务调度任务提交接口接收前端的user_image(Base64/URL) 和cloth_image。调用第三方 AI API (如 Replicate IDM-VTON)。P0状态轮询接口接收task_id，查询 AI
任务状态。如果完成，返回结果图片 URL；如果失败，返回错误码。P0计费逻辑额度扣除 (Quota)在调用 AI API之前，检查该商家的数据库记录，确认是否还有剩余额度。无额度则拒绝请求并返回“升级提示”。P0数据存储商家配置存储使用 Prisma
(SQLite/PostgreSQL) 存储商家的安装信息、Session 和当前套餐状态。P0临时图片处理如果前端直接传 Base64，后端需将其转存为临时 URL (如传到 Shopify Files 或 AWS S3)，因为许多 AI API 仅接受
URL 输入。P1

导出到 Google 表格

----------------------------------------------------------------------------------------------------------------------------------


4. 非功能性需求 (NON-FUNCTIONAL REQUIREMENTS)

 1. 性能 (Performance):
    
    * 图片压缩: 前端上传前必须压缩图片（建议长边不超过 1024px），减少网络传输时间。
    
    * 接口响应: Backend 接收请求的接口响应时间应 < 500ms（异步处理 AI 任务）。

 2. 安全性 (Security):
    
    * API Key 保护: 第三方 AI 服务的 API Key (如 Replicate Token) 必须存储在后端环境变量中，严禁暴露在前端代码里。
    
    * 内容审核: 依赖 AI 接口的内容过滤器，防止生成色情或暴力图片。

 3. 兼容性 (Compatibility):
    
    * 移动优先: 70% 的 Shopify 流量来自移动端，弹窗必须完美适配 iOS/Android 的 WebView。
    
    * 主题兼容: 浮球的 z-index 需设得足够高，避免被店铺原有的 Chat bot 或 Cookie banner 遮挡。


下一步建议

确认这份清单无误后，我们可以开始进入技术实施阶段。
你可以选择：

 1. 先写前端 (Liquid/JS)：把浮球和弹窗画出来。

 2. 先写后端 (Remix)：把调用 AI 的接口跑通。

你想从哪一部分开始？




---

